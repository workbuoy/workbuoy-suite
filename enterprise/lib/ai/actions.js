import path from 'path';import sqlite3 from 'sqlite3';const DB_PATH=process.env.DB_PATH||path.join(process.cwd(),'db','workbuoy.db');export async function executeAction(tenant_id,action){const db=new sqlite3.Database(DB_PATH);const type=action.type;const params=action.params||{};let before=null,after=null,status='applied';if(type==='send_message'){const msg={to:params.to,channel:params.channel||'email',body:params.body};after={sent:true,...msg};await run(db,`INSERT INTO audit_logs_worm(action,details,tenant_id) VALUES(?,?,?)`,['ai:send_message',JSON.stringify(msg),tenant_id]);}else if(type==='update_status'){const row=await get(db,`SELECT id,ext_id,status,assignee FROM tickets WHERE (tenant_id=? OR tenant_id IS NULL) AND (id=? OR ext_id=?)`,[tenant_id,params.ticket_id,params.ticket_id]);before=row||null;await run(db,`UPDATE tickets SET status=COALESCE(?,status), assignee=COALESCE(?,assignee), updated_at=datetime('now') WHERE (tenant_id=? OR tenant_id IS NULL) AND (id=? OR ext_id=?)`,[params.status||null,params.assignee||null,tenant_id,params.ticket_id,params.ticket_id]);after={ticket_id:params.ticket_id,status:params.status||row?.status,assignee:params.assignee||row?.assignee};}else if(type==='create_task'){const r=await run(db,`INSERT INTO ai_tasks(tenant_id,title,due_at,status) VALUES(?,?,?,?)`,[tenant_id,params.title||'Oppgave',params.due_at||null,'open']);after={task_id:r.lastID,title:params.title,due_at:params.due_at};}else if(type==='create_meeting'){const r=await run(db,`INSERT INTO ai_tasks(tenant_id,title,due_at,status) VALUES(?,?,?,?)`,[tenant_id,`[Møte] ${params.title||'Kundemøte'}`,params.due_at||null,'open']);after={task_id:r.lastID,title:params.title,due_at:params.due_at};}else{status='failed';}const log=await run(db,`INSERT INTO ai_actions_log(tenant_id,action_type,payload_before,payload_after,context,status) VALUES(?,?,?,?,?,?)`,[tenant_id,type,JSON.stringify(before),JSON.stringify(after),JSON.stringify(action.context||{}),status]);return { ok: status==='applied', action_id: log.lastID, before, after };}export async function undoAction(tenant_id,action_id){const db=new sqlite3.Database(DB_PATH);const row=await get(db,`SELECT id,action_type,payload_before,payload_after,status FROM ai_actions_log WHERE id=? AND tenant_id=?`,[action_id,tenant_id]);if(!row)return {ok:false,error:'not_found'};if(row.status==='reverted')return {ok:true,reverted:true};const type=row.action_type;const before=row.payload_before?JSON.parse(row.payload_before):null;const after=row.payload_after?JSON.parse(row.payload_after):null;if(type==='update_status'&&before){await run(db,`UPDATE tickets SET status=?, assignee=? WHERE (tenant_id=? OR tenant_id IS NULL) AND (id=? OR ext_id=?)`,[before.status,before.assignee,tenant_id,before.id||after?.ticket_id,before.ext_id||after?.ticket_id]);}else if((type==='create_task'||type==='create_meeting')&&after?.task_id){await run(db,`UPDATE ai_tasks SET status='cancelled' WHERE tenant_id=? AND id=?`,[tenant_id,after.task_id]);}await run(db,`UPDATE ai_actions_log SET status='reverted', reverted_at=datetime('now') WHERE id=?`,[action_id]);return {ok:true,reverted:true};}function run(db,sql,params=[]){return new Promise((resolve,reject)=>db.run(sql,params,function(err){if(err)reject(err);else resolve(this);}));}function get(db,sql,params=[]){return new Promise((resolve,reject)=>db.get(sql,params,(err,row)=>{if(err)reject(err);else resolve(row);}));}